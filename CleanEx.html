<script>

    // 임시변수 사용을 줄이는 것이 중요
    // 배열 고차 함수
    const price = ['2000', '1000', '3000', '5000', '4000'];

    function getWonPrice(priceList) {
        let temp = [];
        for(let i=0; i<priceList.length; i++) {
            temp.push(priceList[i] + ' 원');        
        }
        return temp;
    }

    // 고차원 함수로 바꾸기 !
    function getWonPrice(priceList) {
        // let temp = [];
        // index i 가 굉장히 추상적으로 생각될 수  있음 
        // for(let i=0; i<priceList.length; i++) {
        //     temp.push(priceList[i] + ' 원');        
        // }
        
        // 고차원 함수 map 을 이용하여 Refcatroing 구현이 가능 
        return priceList.map((price) => price + ' 원');
    
        // 추가 요구 사항 1000 원 이상 항목만 표출 하기 
        
        const isOverList = priceList.filter(isOverOneThousand);
        
        return isOverList.map(suffixWon);

        // 추가 요구사항 가격 순 정렬 
        const sortList = priceList.filter(isOverOneThousand);    
    
    }

    const suffixWon = (price) => price + ' 원';
    const isOverOneThousand = (price) => Number(price) > 1000;

    const result = getWonPrice(price);

    console.log('result Check : ' + result);

    // 배열 메서드 체이닝 
    // for 와 if 문 으로 가득하면 코드 가독성이 떨어지게 됨 
    // MethodChaining
    // const ascendingList = (a, b) => a - b;


    // 내장 메서드들을 잘 활용하는 것이 중요 
    function getWonPrice(priceList) {
        // 메서드 체이닝을 사용 (첫번 쨰 필터를 걸고 두번쨰는 정렬을 사용 세번째는 새로운 배열을 조작하여 만들어 냄)
        // 메서드 체이닝을 잘 활용하면 명시적으로 표현을 해주므로 파이프 라인처럼 보일 수도 있음 
        return priceList
            .filter(isOverOneThousand)
           // .sort(ascendingList)    // sort 정렬
            .map(suffixWon);        // map 을 통하여 배열 요소들을 다시 정리 
    }


    const ascendingList = (a, b) => a - b;


    const wonResult = getWonPrice(price);

    const prices = ['2000', '1000', '3000', '5000', '4000'];

    // map 이랑 forEach 차이를 숙지하여야 함
    const newPricesForEach = prices.forEach((price) => price + ' 원');
   
    const newPricesMap = prices.map((price) => price + ' 원');

    // 차이점은 콜백 함수 차이점이 있음 
    // forEach 는 undefined 가 나옴  
    // forEach 는 주어진 요소들을 하나하나 돌리면서 요소마다 함수를 실행시켜 줌
    const newPricesForEach_test = prices.forEach(function (price) {
        return price + ' 원';
    });
    
    // map 은 새로운 배열을 만들어 냄
    // map 은 배열에 조작을 가함  
    
    const newPricesMap_test = prices.map(function (price) {
        return price + ' 원';
    });
    
    // 즉 map 은 원본 배열을 손상시키지 않으면서 새로운 배열을 만들어 내고
    // forEach 는 요소 마다 그냥 함수를 실행시키는 역할을 함 (새로운 배열을 return 하여 주지 않음 )
    // forEach 는 return 값은 undefined 임 

    // 매 요소마다 함수를 실행 시키는 것은 forEach 를 권장 (요소가 Loop 될 때 마다 함수를 실행 시켜 줌)
    // 새로운 배열을 만드는 것은 map 사용을 권장 

    console.log('new Prices map : ' + newPricesMap_test);
    console.log('new price forEach : ' + newPricesForEach_test);

    // continue / break
    const orders = ['first', 'second', 'third'];

    orders.forEach(function (order) {
        if(order == 'second') {
           // continue ;    --> forEach 에서 continue 랑 break 는 사용이 불가 Syntax Error 가 발생 
           // break;
           // forEach 에서는 continue / break 사용 불가이므로 try catch 사용을 권장
           // 아니면 for 문을 사용하거니 for of 나 for in 을 사용 
        }
        console.log('order : ' + order);
    })
     
    // forEach() 를 중간에 멈출 수 없으므로 아래 내장 메서드 사용을 권장  
    // 아니면 every some 이나 find findInex 내장 메서드를 사용 시 찾으면 그 즉시 루프를 종료함 


    // Shorthand Properties / Concise Method ==> 항사 고려하기 










</script>